@using Blazored.LocalStorage
@using System.Text.Json
@using Todoki.Data.Shared.ViewModels
@using Todoki.Data.ViewModels

@if (IsOpen)
{
    <div class="login-overlay" @onclick="CloseModal">
        <div class="login-content" @onclick:stopPropagation>
            <div class="auth-toggle">
                <button class="@(IsLogin ? "active" : "")" @onclick="() => ToggleLogin(true)">Login</button>
                <button class="@(IsLogin ? "" : "active")" @onclick="() => ToggleLogin(false)">Register</button>
            </div>

            <EditForm EditContext="editContext" OnValidSubmit="@HandleSubmit">
                <DataAnnotationsValidator />

                <div class="input-group">
                    <InputText placeholder="Email" @bind-Value="registerModel.EmailAddress" />
                    <ValidationMessage For="@(() => registerModel.EmailAddress)" />
                </div>

                <div class="input-group">
                    <InputText type="password"
                               placeholder="Password"
                               @bind-Value="registerModel.Password"
                               @oninput="HandlePasswordChanged" />
                    <ValidationMessage For="@(() => registerModel.Password)" />
                </div>

                @if (!IsLogin)
                {
                    <div class="input-group">
                        <InputText type="password"
                                   placeholder="Confirm Password"
                                   @bind-Value="ConfirmPassword" />
                        @if (!string.IsNullOrEmpty(PasswordMismatchError))
                        {
                            <p class="login-error">@PasswordMismatchError</p>
                        }
                    </div>

                    <!-- Show password requirements only when user starts typing -->
                    @if (showRequirements)
                    {
                        <div class="password-requirements">
                            <div class="requirement @(requirements["minLength"] ? "valid" : "invalid")">
                                ● At least 8 characters
                            </div>
                            <div class="requirement @(requirements["lowercase"] ? "valid" : "invalid")">
                                ● One lowercase letter (a-z)
                            </div>
                            <div class="requirement @(requirements["uppercase"] ? "valid" : "invalid")">
                                ● One uppercase letter (A-Z)
                            </div>
                            <div class="requirement @(requirements["digit"] ? "valid" : "invalid")">
                                ● One number (0-9)
                            </div>
                        </div>
                    }
                }

                <button class="auth-btn" type="submit" disabled="@isSubmitting">
                    @if (isSubmitting)
                    {
                        <span>Processing...</span>
                    }
                    else
                    {
                        @(IsLogin ? "Login" : "Register")
                    }
                </button>
            </EditForm>

            @if (!string.IsNullOrEmpty(Error))
            {
                <div class="login-error">
                    @foreach (var line in Error.Split('\n', StringSplitOptions.RemoveEmptyEntries))
                    {
                        <div>@line</div>
                    }
                </div>
            }
        </div>
    </div>
}

@code {
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public EventCallback<bool> IsOpenChanged { get; set; }
    [Inject] private HttpClientWrapper Http { get; set; }
    [Inject] private ILocalStorageService LocalStorage { get; set; }
    [Inject] private NavigationManager Nav { get; set; }
    [Inject] private JwtAuthenticationStateProvider AuthProvider { get; set; }

    private bool IsLogin = true;
    private bool isSubmitting = false;
    private EditContext editContext = default!;
    private RegisterRequest registerModel = new();
    private string ConfirmPassword = string.Empty;
    private string Error = string.Empty;
    private string PasswordMismatchError = string.Empty;

    // Track if user has started typing (to show requirements)
    private bool showRequirements = false;

    // Real-time password feedback
    private Dictionary<string, bool> requirements = new()
    {
        { "minLength", false },
        { "lowercase", false },
        { "uppercase", false },
        { "digit", false }
    };

    protected override void OnInitialized()
    {
        editContext = new EditContext(registerModel);
    }

    protected override void OnParametersSet()
    {
        if (IsOpen)
        {
            editContext = new EditContext(registerModel);
        }
    }

    private void ToggleLogin(bool login)
    {
        IsLogin = login;
        Error = string.Empty;
        PasswordMismatchError = string.Empty;
        registerModel = new();
        ConfirmPassword = string.Empty;
        showRequirements = false;
        requirements = requirements.ToDictionary(k => k.Key, v => false);
        editContext = new EditContext(registerModel);
    }

    private void HandlePasswordChanged(ChangeEventArgs e)
    {
        var pwd = e.Value?.ToString() ?? "";
        registerModel.Password = pwd;

        // Only show requirements after user starts typing
        showRequirements = !string.IsNullOrEmpty(pwd);

        // Evaluate requirements
        requirements["minLength"] = pwd.Length >= 8;
        requirements["lowercase"] = pwd.Any(c => c >= 'a' && c <= 'z');
        requirements["uppercase"] = pwd.Any(c => c >= 'A' && c <= 'Z');
        requirements["digit"] = pwd.Any(char.IsDigit);
    }

    private async Task HandleSubmit()
    {
        if (isSubmitting) return;
        isSubmitting = true;
        Error = string.Empty;
        PasswordMismatchError = string.Empty;

        if (!editContext.Validate())
        {
            isSubmitting = false;
            return;
        }

        if (!IsLogin && registerModel.Password != ConfirmPassword)
        {
            PasswordMismatchError = "Passwords do not match";
            isSubmitting = false;
            return;
        }

        try
        {
            if (IsLogin)
            {
                var loginData = new { emailAddress = registerModel.EmailAddress, password = registerModel.Password };
                var response = await Http.PostAsJsonAsync("api/authentication/login-user", loginData);

                if (!response.IsSuccessStatusCode)
                {
                    var text = await response.Content.ReadAsStringAsync();
                    Error = FormatErrorResponse(text);
                    return;
                }

                var authResponse = await Http.ReadFromJsonAsync<AuthResponse>(response);
                if (authResponse?.IsSuccess == true)
                {
                    await LocalStorage.SetItemAsync("authToken", authResponse.Token);
                    await LocalStorage.SetItemAsync("refreshToken", authResponse.RefreshToken);
                    AuthProvider.MarkUserAsAuthenticated(authResponse.Token);
                    Nav.NavigateTo("/", forceLoad: true);
                    await CloseModal();
                }
                else
                {
                    Error = authResponse?.Error ?? "Login failed";
                }
            }
            else
            {
                var response = await Http.PostAsJsonAsync("api/authentication/register-user", registerModel);

                if (response.IsSuccessStatusCode)
                {
                    // Auto-login after successful registration
                    IsLogin = true;
                    await HandleSubmit();
                    return;
                }

                var errorText = await response.Content.ReadAsStringAsync();
                Error = FormatErrorResponse(errorText);
            }
        }
        catch (Exception ex)
        {
            Error = "An error occurred. Please try again.";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isSubmitting = false;
        }
    }

    private string FormatErrorResponse(string errorText)
    {
        if (string.IsNullOrWhiteSpace(errorText)) return "Operation failed.";

        // Trim and clean up
        errorText = errorText.Trim();

        // If it's a quoted string
        if (errorText.StartsWith("\"") && errorText.EndsWith("\""))
        {
            return errorText[1..^1];
        }

        try
        {
            using var doc = JsonDocument.Parse(errorText);
            var root = doc.RootElement;

            // Case 1: { "errors": { "Field": [ "msg" ] } }
            if (root.TryGetProperty("errors", out var errorsElement) && errorsElement.ValueKind == JsonValueKind.Object)
            {
                var allErrors = new List<string>();
                foreach (var prop in errorsElement.EnumerateObject())
                {
                    foreach (var msg in prop.Value.EnumerateArray())
                    {
                        allErrors.Add(HumanizeMessage(msg.GetString() ?? ""));
                    }
                }
                return string.Join("\n", allErrors.Distinct());
            }

            // Case 2: { "error": "..." }
            if (root.TryGetProperty("error", out var errorProp))
            {
                return HumanizeMessage(errorProp.GetString() ?? "");
            }

            // Case 3: Problem Details (title/detail)
            string title = root.TryGetProperty("title", out var t) ? t.GetString() : null;
            string detail = root.TryGetProperty("detail", out var d) ? d.GetString() : null;

            if (!string.IsNullOrEmpty(title) || !string.IsNullOrEmpty(detail))
            {
                var parts = new List<string>();
                if (!string.IsNullOrEmpty(title)) parts.Add(HumanizeMessage(title));
                if (!string.IsNullOrEmpty(detail) && !title?.Contains(detail, StringComparison.OrdinalIgnoreCase) == true)
                    parts.Add(HumanizeMessage(detail));
                return string.Join("\n", parts);
            }

            // Fallback
            return errorText.Split('\n').First().Trim().Replace("\"", "");
        }
        catch (JsonException)
        {
            return errorText.Split('\n').First().Trim().Replace("\"", "");
        }
    }

    private string HumanizeMessage(string msg)
    {
        return msg switch
        {
            string m when m.Contains("uppercase", StringComparison.OrdinalIgnoreCase)
                => "Password must contain at least one uppercase letter (A-Z)",
            string m when m.Contains("lowercase", StringComparison.OrdinalIgnoreCase)
                => "Password must contain at least one lowercase letter (a-z)",
            string m when m.Contains("digit", StringComparison.OrdinalIgnoreCase)
                => "Password must contain at least one number (0-9)",
            string m when m.Contains("length") || (m.Contains("8") && m.Contains("character", StringComparison.OrdinalIgnoreCase))
                => "Password must be at least 8 characters long",
            _ => msg
        };
    }

    private async Task CloseModal()
    {
        IsOpen = false;
        await IsOpenChanged.InvokeAsync(IsOpen);
    }
}

<style>
    .login-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 20px;
    }

    .login-content {
        background-color: #121212;
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        width: 320px;
        max-width: 95vw;
        font-family: sans-serif;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

        .login-content form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

    .auth-toggle {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
    }

        .auth-toggle button {
            flex: 1;
            padding: 0.6rem;
            border-radius: 6px;
            border: 1px solid #444;
            background: #121212;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

            .auth-toggle button.active {
                background: #4cd137;
                color: black;
                font-weight: 600;
            }

    .input-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .login-content input {
        padding: 0.75rem;
        border-radius: 6px;
        border: 1px solid #444;
        background-color: #121212;
        color: white;
        width: 100%;
        box-sizing: border-box;
        font-size: 1rem;
        transition: border-color 0.2s;
    }

        .login-content input:focus {
            outline: none;
            border-color: #4cd137;
        }

    .validation-message {
        color: #e74c3c;
        font-size: 0.8rem;
        margin: 0;
    }

    .login-error {
        color: #e74c3c;
        font-size: 0.9rem;
        margin: 0.5rem 0 0 0;
        text-align: center;
        white-space: pre-line;
    }

    .password-requirements {
        margin-top: 0.5rem;
        padding: 0.5rem;
        background-color: #1a1a1a;
        border-radius: 4px;
        font-size: 0.85rem;
        line-height: 1.5;
    }

    .requirement {
        margin: 0.25rem 0;
        color: #ccc;
        transition: color 0.2s ease;
    }

        .requirement.valid {
            color: #4cd137; /* Sleek green */
        }

        .requirement.invalid {
            color: #666; /* Subtle gray when not met */
        }
</style>