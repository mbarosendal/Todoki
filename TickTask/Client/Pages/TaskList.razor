@using TickTask.Client.Services
@using TickTask.Shared
@inject TaskService TaskService
@inject TimerService TimerService
@inject IJSRuntime JS
@inject ILogger<TaskList> Logger



<!-- Active Task Section -->
<div class="active-task-section">
	@if (!hideActiveTask)
	{
		<div class="active-task-content" style="min-height:60px">
			@if (ActiveTask != null)
			{
				<div class="active-task-left">
					<div class="section-label">Current task</div>
					<div class="active-task-name">@ActiveTask.Name</div>
				</div>
				<div class="active-task-right" title="Pomodoro progress on current task">
					<div class="task-info-row">
						🍅 @ActiveTask.PomodorosRanOnTask/@ActiveTask.EstimatedNumberOfPomodoros
					</div>
					<div class="task-info-row" title="Your estimated minutes of work left on current task (breaks excluded)">
						⏳ @((((ActiveTask.EstimatedNumberOfPomodoros - ActiveTask.PomodorosRanOnTask - 1) * ActivePomodoro.Duration.TotalMinutes) + ActivePomodoro.RemainingTime.TotalMinutes).ToString("0")) min
					</div>
					<div class="task-info-row" title="The estimated time of current task completion (breaks included)">
						🕒 @TimerService.CalculateEstimatedTimeOfTaskCompletion(ActivePomodoro, ActiveShortBreakTimer, ActiveLongBreakTimer, ActiveTask, TimerSettings)
					</div>
				</div>
			}
			else
			{
				<div class="active-task-left">
					<div class="active-task-name">@(HasMoreTasks() ? "No current task set" : "All done (No tasks left)")</div>
				</div>
			}

		</div>
		<!-- Active Task Check-in-->
		@if (IsOnBreak && ActiveTask != null)
		{
			<div class="checkin-container">
				<div class="question-label">How is it going?</div>
				<div class="checkin-buttons">
					<button class="checkin-btn on-time" @onclick="HandleOnTime">
						<div class="btn-icon">👍</div>
						<div class="btn-text">
							<div class="btn-title">I'll have it done on time (Around @TimerService.CalculateEstimatedTimeOfTaskCompletion(ActivePomodoro, ActiveShortBreakTimer, ActiveLongBreakTimer, ActiveTask, TimerSettings))</div>
						</div>
					</button>
					<button class="checkin-btn need-time" @onclick="HandleNeedMoreTime">
						<div class="btn-icon">⏰</div>
						<div class="btn-text">
							<div class="btn-title">I need more time (Add @((int)ActivePomodoro.Duration.TotalMinutes) min)</div>
						</div>
					</button>
					<button class="checkin-btn task-done" @onclick="HandleTaskDone">
						<div class="btn-icon">✅</div>
						<div class="btn-text">
							<div class="btn-title">I'm done with this task (Mark done & move to next)</div>
						</div>
					</button>
				</div>
			</div>
		}
	}
</div>

<!-- Tasks Section -->
<div class="tasks-section">
	@if (!IsOnBreak)
	{
		<div class="tasks-header">
			<div class="section-label">Tasks</div>
			<button class="menu-btn" @onclick="ToggleMenu">⋮</button>
		</div>
	}

	<!-- Popup menu -->
	@if (showMenu)
	{
		<div class="menu-popup" @onclick="() => showMenu = false">
			<button class="menu-item" @onclick="ClearFinished">Clear finished tasks</button>
			<button class="menu-item" @onclick="ConfirmClearAll">Clear all tasks</button>
			<button class="menu-item" @onclick="HideActiveTask">@(hideActiveTask ? "Show active task" : "Hide active task")</button>
			<button class="menu-item" @onclick="HideTasks">@(hideTasks ? "Show tasks" : "Hide tasks")</button>
			<button class="menu-item" @onclick="OnResetPomodoros">Reset Pomodoro</button>
		</div>
	}

	<!-- Tasks display -->
	@if (tasks == null)
	{
		<div class="loading">Loading tasks...</div>
	}
	else if (hideTasks)
	{
		<div class="tasks-hidden">Tasks are hidden.</div>
	}
	else if (IsOnBreak)
	{
		<div class="section-label">@(GetBreakText() == "" ? "Take a break!" : "Reminder")</div>

		<div class="break-screen">
			<div class="break-message">
				@if (GetBreakText() == "")
				{
					<div class="break-icon">🌴</div>
				}
				else
				{
					<p class="break-text">@GetBreakText()</p>
				}
			</div>
		</div>
	}
	else
	{
		<div class="tasks-list">
			@foreach (var task in tasks)
			{
				<div class="task-item @(task.IsActiveTask ? "active" : "") @(task.IsDone ? "completed" : "")"
					 @onclick="() => SetActiveTask(task.TaskItemId)"
					 @onwheel="(e) => AdjustEstimatedPomodoros(task.TaskItemId, e.DeltaY)"
					 @onwheel:preventDefault="true">

					<input type="checkbox"
						   class="task-checkbox"
						   checked="@task.IsDone"
						   @onclick="() => FinishTask(task.TaskItemId)"
						   @onclick:stopPropagation="true">

					<div class="task-info">
						<span class="task-progress">@task.PomodorosRanOnTask/@task.EstimatedNumberOfPomodoros</span>
					</div>

					@if (editingTaskId == task.TaskItemId)
					{
						<input class="task-edit-input @(task.IsDone ? "completed" : "")"
							   @bind="task.Name"
							   @bind:event="oninput"
							   @onblur="() => FinishEdit(task)"
							   @onclick:stopPropagation="true"
							   placeholder="Edit task..." />
					}
					else
					{
						<span class="task-name @(task.IsDone ? "completed" : "")">@task.Name</span>
					}

					<div class="task-actions">
						<button class="task-btn" @onclick="() => StartEdit(task.TaskItemId)" @onclick:stopPropagation="true">✎</button>
						<button class="task-btn" @onclick="() => DeleteTask(task.TaskItemId)" @onclick:stopPropagation="true">❌</button>
						<button class="task-btn" @onclick:stopPropagation="true">⋯</button>
					</div>
				</div>
			}
		</div>

		<div class="add-task-section">
			<button class="add-task-btn" @onclick="AddTask">Add Task</button>
		</div>
	}
</div>

<!-- Style for break screen, clean before add to overall style-->
<style>
	.break-screen {
		text-align: center;
		padding: 20px 20px;
	}

	.break-icon {
		font-size: 4rem;
		margin-bottom: 16px;
	}

	.break-text {
		font-size: 1.1rem;
		background: rgba(0, 0, 0, 0.2);
		opacity: 0.9;
		line-height: 1.6;
		max-width: 600px;
		margin: 0 auto;
		padding: 15px;
		word-wrap: break-word;
		border-radius: 10px;
	}

	.checkin-container {
		background: rgba(0, 0, 0, 0.2);
		opacity: 0.9;
		border-radius: 10px;
		padding: 10px;
		display: flex;
		align-items: center;
		max-width: 350px;
		margin: 25px auto auto auto;
	}

	.question-label {
		font-size: 1.1rem;
		margin: 0px 35px 0px 10px;
		white-space: nowrap;
	}

	.checkin-buttons {
		display: flex;
		flex-direction: row;
		gap: 10px;
		flex: 1;
	}

	.checkin-btn {
		background: rgba(255, 255, 255, 0.1);
		border: none;
		border-radius: 4px;
		padding: 8px 12px;
		color: white;
		cursor: pointer;
		transition: background 0.3s ease;
		display: flex;
		align-items: center;
		gap: 8px;
	}

		.checkin-btn:hover {
			background: rgba(255, 255, 255, 0.2);
		}

		.checkin-btn .btn-icon {
			font-size: 1rem;
		}

		.checkin-btn .btn-text {
			display: none; /* Hide text to make buttons minimalistic */
		}

		.checkin-btn .btn-title {
			font-size: 0.9rem;
		}

		/* Tooltip styling */
		.checkin-btn:hover .btn-text {
			display: block;
			position: absolute;
			background: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 5px 10px;
			border-radius: 4px;
			margin-top: 30px;
			z-index: 100;
			white-space: nowrap;
		}
</style>

<style>
	/* Active Task Section */
	.active-task-section {
		background: rgba(10, 137, 18, 1);
		border-radius: 12px 12px 0 0;
		padding: 16px 20px;
		margin-top: 20px;
		position: relative;
	}

	/* Tasks Section */
	.tasks-section {
		background: rgba(89, 8, 8, 0.25);
		border-radius: 0 0 12px 12px;
		padding: 16px 20px 20px 20px;
		margin-top: 0;
	}

	/* Section labels */
	.section-label {
		font-size: 1.1rem;
		font-weight: 500;
		margin-bottom: 12px;
		opacity: 0.9;
	}

	/* Tasks header */
	.tasks-header {
		display: flex;
		justify-content: space-between;
		align-items: flex-start;
		margin-bottom: 16px;
	}

	/* Active task content */
	.active-task-content {
		display: flex;
		justify-content: space-between;
		align-items: flex-start;
		gap: 16px;
	}

	.active-task-left {
		display: flex;
		flex-direction: column;
	}

	.active-task-right {
		display: flex;
		flex-direction: column;
		align-items: flex-end;
		justify-content: center;
		gap: 6px;
	}

	.task-info-row {
		font-size: 0.9rem;
		opacity: 0.9;
	}

	.active-task-name {
		font-size: 1.1rem;
		font-weight: 500;
		flex: 1;
	}

	.active-task-progress {
		font-size: 0.9rem;
		margin-left: 12px;
	}

	/* Menu and buttons */
	.menu-btn, .task-btn, .add-task-btn {
		border: none;
		color: white;
		cursor: pointer;
		transition: all 0.3s ease;
	}

	.menu-btn {
		background: rgba(255,255,255,0.1);
		padding: 6px 10px;
		border-radius: 6px;
		font-size: 1.2rem;
	}

		.menu-btn:hover {
			background: rgba(255,255,255,0.2);
		}

	.menu-popup {
		position: absolute;
		right: 25%;
		top: 50%;
		background: rgba(0, 0, 0, 0.8);
		border-radius: 8px;
		padding: 8px 0;
		width: 180px;
		z-index: 1000;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	}

	.menu-item {
		width: 100%;
		background: none;
		border: none;
		color: white;
		padding: 10px 16px;
		text-align: left;
		cursor: pointer;
		transition: background 0.2s ease;
	}

		.menu-item:hover {
			background: rgba(255,255,255,0.1);
		}

	/* Loading and hidden states */
	.loading, .tasks-hidden {
		text-align: center;
		padding: 20px;
		opacity: 0.7;
		font-style: italic;
	}

	/* Task items */
	.task-item {
		display: flex;
		align-items: center;
		background: rgba(0,0,0,0.2);
		padding: 12px 16px;
		border-radius: 8px;
		margin-bottom: 8px;
		cursor: pointer;
		transition: all 0.2s ease;
		gap: 12px;
		min-height: 50px;
	}

		.task-item:hover {
			background: rgba(0,0,0,0.3);
		}

		.task-item.active {
			border-left: 4px solid #228B22;
		}

		.task-item.completed {
			opacity: 0.6;
		}

	.task-checkbox {
		flex-shrink: 0;
		width: 18px;
		height: 18px;
		cursor: pointer;
		appearance: none;
		border: 2px solid black;
		border-radius: 4px;
		position: relative;
		background-color: white;
		transition: background-color 0.2s, transform 0.2s;
	}

		.task-checkbox::after {
			content: '';
			position: absolute;
			width: 4px;
			height: 8px;
			border-right: 2px solid white;
			border-bottom: 2px solid white;
			top: 2px;
			left: 6px;
			transform: rotate(45deg) scale(0);
			transition: transform 0.2s ease;
		}

		.task-checkbox:checked {
			background-color: #007f3f;
			border-color: #007f3f;
			transform: scale(1.15);
		}

			.task-checkbox:checked::after {
				transform: rotate(45deg) scale(1);
			}

		.task-checkbox:not(:checked) {
			transform: scale(1);
		}


	/* Task text content */
	.task-name, .task-edit-input {
		flex: 1;
		color: white;
		font-size: 1rem;
	}

		.task-name.completed, .task-edit-input.completed {
			text-decoration: line-through;
			opacity: 0.7;
		}

	.task-edit-input {
		background: rgba(255,255,255,0.1);
		border: 1px solid rgba(255,255,255,0.2);
		border-radius: 4px;
		padding: 6px 8px;
	}

		.task-edit-input:focus {
			outline: none;
			border-color: rgba(255,255,255,0.4);
		}

	/* Task info and actions */
	.task-info {
		opacity: 0.7;
		font-size: 0.9rem;
		min-width: 40px;
		transition: opacity 0.2s ease;
	}

	.task-actions {
		opacity: 0;
		transition: opacity 0.2s ease;
		min-width: 80px;
		display: flex;
		gap: 4px;
		justify-content: flex-end;
	}

	/* .task-item:hover .task-info { */
	/* opacity: 0; */
	/* } */

	.task-item:hover .task-actions {
		opacity: 1;
	}

	.task-btn {
		background: rgba(255,255,255,0.1);
		padding: 4px 6px;
		border-radius: 4px;
		font-size: 0.8rem;
		min-width: 24px;
		transition: all 0.2s ease;
	}

		.task-btn:hover {
			background: rgba(255,255,255,0.2);
		}

	/* Add task section */
	.add-task-section {
		margin-top: 16px;
		text-align: center;
	}

	.add-task-btn {
		background: rgba(214, 38, 38, 1);
		padding: 12px 24px;
		border-radius: 8px;
		font-size: 1rem;
	}

		.add-task-btn:hover {
			background: rgba(33, 150, 243, 0.4);
			transform: translateY(-1px);
		}
</style>

@code {
	[Parameter] public CountdownTimer CurrentTimer { get; set; } = default!;
	[Parameter] public PomodoroTimer ActivePomodoro { get; set; } = default!;
	[Parameter] public ShortBreakTimer ActiveShortBreakTimer { get; set; } = default!;
	[Parameter] public LongBreakTimer ActiveLongBreakTimer { get; set; } = default!;
	[Parameter] public EventCallback OnResetPomodoros { get; set; }
	[Parameter] public TimerSettings TimerSettings { get; set; } = default!;

	private bool IsOnBreak => CurrentTimer is ShortBreakTimer or LongBreakTimer;

	private string GetBreakText() => CurrentTimer?.Text ?? (CurrentTimer is ShortBreakTimer ? ActiveShortBreakTimer.Text : ActiveLongBreakTimer.Text);

	private List<TaskItem>? tasks = new();
	private TaskItem? activeTask;
	private int? editingTaskId;

	private bool showMenu;
	private bool hideTasks = false;
	private bool hideActiveTask = false;

	public bool AreAllTasksDone = false;
	public bool ShouldPlaySoundAfterAllTasksDone = false;

	public TaskItem? ActiveTask
	{
		get => activeTask;
		set
		{
			activeTask = value;
			StateHasChanged();
		}
	}

	protected override async Task OnInitializedAsync()
	{
		tasks = await TaskService.GetAllAsync();
		await SetNextAvailableTaskIfNoneActive();

		ShouldPlaySoundAfterAllTasksDone = HasMoreTasks();
	}

	private void ToggleMenu() => showMenu = !showMenu;

	private void HideTasks() => hideTasks = !hideTasks;
	private void HideActiveTask() => hideActiveTask = !hideActiveTask;

	public bool HasMoreTasks() => tasks?.Any(t => !t.IsDone) == true;

	public async Task IncrementActivePomodoroCount()
	{
		if (ActiveTask == null) return;

		ActiveTask.PomodorosRanOnTask++;
		await TaskService.UpdateAsync(ActiveTask);

		bool isTaskDone = ActiveTask.PomodorosRanOnTask >= ActiveTask.EstimatedNumberOfPomodoros;

		if (isTaskDone)
		{
			if (TimerSettings.AutomaticallyMarkDoneTasks)
			{
				ActiveTask.IsDone = true;
				await TaskService.UpdateAsync(ActiveTask);
			}

			if (TimerSettings.AutomaticallyClearDoneTasks)
				await DeleteTask(ActiveTask.TaskItemId);

			if (TimerSettings.AutomaticallyProceedToNextTaskAfterDone)
				SetNextTaskAsActive();
		}

		StateHasChanged();
	}

	public async Task SetNextAvailableTaskIfNoneActive()
	{
		if (ActiveTask == null && HasMoreTasks())
		{
			var nextTask = tasks.FirstOrDefault(t => !t.IsDone);
			if (nextTask != null)
			{
				nextTask.IsActiveTask = true;
				await TaskService.UpdateAsync(nextTask);
				ActiveTask = nextTask;
				StateHasChanged();
			}
		}
	}

	public async void SetNextTaskAsActive()
	{
		if (ActiveTask != null)
		{
			ActiveTask.IsActiveTask = false;
			await TaskService.UpdateAsync(ActiveTask);
		}

		if (HasMoreTasks())
		{
			var nextTask = await GetNextTask();
			if (nextTask != null)
			{
				nextTask.IsActiveTask = true;
				await TaskService.UpdateAsync(nextTask);
				ActiveTask = nextTask;
			}
			else
			{
				ActiveTask = null;
			}
		}
		else
		{
			ActiveTask = null;
		}
	}

	public async Task<TaskItem?> GetNextTask()
	{
		var nextTask = tasks?.FirstOrDefault(t => !t.IsDone && !t.IsActiveTask);

		// var currentIndex = tasks!.FindIndex(t => t.TaskItemId == ActiveTask?.TaskItemId);
		// var nextTask = tasks!.Skip(currentIndex + 1).FirstOrDefault(t => !t.IsDone);

		if (nextTask != null)
		{
			await SetActiveTask(nextTask.TaskItemId);
			return nextTask;
		}
		return null;
	}


	private async Task ConfirmClearAll()
	{
		bool confirmed = await JS.InvokeAsync<bool>("confirm", "Are you sure you want to clear all tasks? This cannot be undone.");

		if (confirmed)
		{
			ClearAll();
		}
	}

	private void ClearFinished()
	{
		foreach (var task in tasks!.Where(t => t.IsDone).ToList())
		{
			_ = TaskService.DeleteAsync(task.TaskItemId);
			tasks.Remove(task);
		}
	}

	private void ClearAll()
	{
		foreach (var task in tasks!.ToList())
		{
			_ = TaskService.DeleteAsync(task.TaskItemId);
		}
		tasks!.Clear();
	}

	private async Task AddTask()
	{
		var newTask = new TaskItem
			{
				Name = "New Task"/*, ProjectId = 1*/
			};
		var created = await TaskService.CreateAsync(newTask);

		if (created != null)
		{
			tasks!.Add(created);
			editingTaskId = created.TaskItemId;

			ShouldPlaySoundAfterAllTasksDone = true;
			StateHasChanged();
		}
	}

	private async Task SetActiveTask(int taskId)
	{
		if (ActiveTask != null)
		{
			ActiveTask.IsActiveTask = false;
			await TaskService.UpdateAsync(ActiveTask);
		}

		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskId);
		if (task != null && !task.IsDone)
		{
			task.IsActiveTask = true;
			await TaskService.UpdateAsync(task);
			ActiveTask = task;
		}
	}

	private void FinishTask(int taskId)
	{
		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskId);

		if (task != null)
		{
			task.IsDone = !task.IsDone;
			_ = TaskService.UpdateAsync(task);
		}
	}

	private void StartEdit(int taskId) => editingTaskId = taskId;

	private async Task FinishEdit(TaskItem task)
	{
		editingTaskId = null;

		if (string.IsNullOrWhiteSpace(task.Name))
		{
			await DeleteTask(task.TaskItemId);
			return;
		}

		await TaskService.UpdateAsync(task);
	}

	private async Task DeleteTask(int taskItemId)
	{
		var success = await TaskService.DeleteAsync(taskItemId);

		if (success)
		{
			activeTask = null;

			tasks!.RemoveAll(t => t.TaskItemId == taskItemId);
		}
	}

	private async Task HandleOnTime()
	{
		// positive effect to mark task as on time ? toggle other buttons when one is selected?
		await JS.InvokeVoidAsync("playClickSound");
	}

	private async Task HandleNeedMoreTime()
	{
		if (ActiveTask != null)
		{
			ActiveTask.EstimatedNumberOfPomodoros++;
			await TaskService.UpdateAsync(ActiveTask);
			StateHasChanged();
		}
		await JS.InvokeVoidAsync("playClickSound");
	}

	private async Task HandleTaskDone()
	{
		if (ActiveTask != null)
		{
			ActiveTask.IsDone = true;
			await TaskService.UpdateAsync(ActiveTask);
			SetNextTaskAsActive();
		}

		await JS.InvokeVoidAsync("playClickSound");

		if (HasMoreTasks() == false)
		{
			await JS.InvokeVoidAsync("playTasksDoneSound");
			ShouldPlaySoundAfterAllTasksDone = false;
		}
	}

	private async Task AdjustEstimatedPomodoros(int taskId, double deltaY)
	{
		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskId);
		if (task == null) return;

		int change = deltaY < 0 ? 1 : -1;
		int newValue = Math.Max(1, task.EstimatedNumberOfPomodoros + change);

		if (newValue != task.EstimatedNumberOfPomodoros)
		{
			if (newValue <= task.PomodorosRanOnTask)
			{
				task.IsDone = true;
				if (HasMoreTasks() == false)
					ShouldPlaySoundAfterAllTasksDone = false;
			}
			if (newValue > task.PomodorosRanOnTask)
			{
				task.IsDone = false;
				ShouldPlaySoundAfterAllTasksDone = true;
			}

			task.EstimatedNumberOfPomodoros = newValue;
			await TaskService.UpdateAsync(task);
			StateHasChanged();
		}
	}
}