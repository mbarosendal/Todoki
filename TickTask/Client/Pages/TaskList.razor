@using TickTask.Client.Services
@using TickTask.Shared
@inject TaskApiService TaskApiService
@inject TimerService TimerService
@inject IJSRuntime JS
@inject ILogger<TaskList> Logger

<!-- Active Task Section -->
<div class="tasks-wrapper">
	<div class="active-task-section">
		@if (!Settings.HideActiveTask)
		{
			<div class="active-task-content" style="min-height:60px">
				@if (ActiveTask != null)
				{
					<div class="active-task-left">
						<div class="section-label">Current task</div>
						<div class="active-task-name">@ActiveTask.Name</div>
					</div>
					<div class="active-task-right">
						<div class="task-info-row tooltip">
							🍅 @ActiveTask.PomodorosRanOnTask/@ActiveTask.EstimatedNumberOfPomodoros
							<div class="tooltip-text">Pomodoro progress on current task</div>
						</div>
						<div class="task-info-row tooltip">
							⏳ @((((ActiveTask.EstimatedNumberOfPomodoros - ActiveTask.PomodorosRanOnTask - 1) * ActivePomodoro.Duration.TotalMinutes)
												+ ActivePomodoro.RemainingTime.TotalMinutes).ToString("0")) min
							<div class="tooltip-text">Your estimated minutes of work left on current task (breaks excluded)</div>
						</div>
						<div class="task-info-row tooltip">
							🕒 @TimerService.CalculateEstimatedTimeOfTaskCompletion(ActivePomodoro, ActiveShortBreakTimer, ActiveLongBreakTimer, ActiveTask, Settings)
							<div class="tooltip-text">The estimated time of current task completion (breaks included)</div>
						</div>
					</div>
				}
				else
				{
					<div class="active-task-left">
						<div class="active-task-name">@(HasMoreTasks() ? "No current task set" : "All done!")</div>
					</div>
				}
			</div>

			<!-- Active Task Check-in-->
			@if (IsOnBreak && ActiveTask != null)
			{
				<div class="checkin-container">
					<div class="question-label">How is it going?</div>
					<div class="checkin-buttons">
						<div class="task-info-row tooltip" @onclick="HandleOnTime" style="cursor: pointer;">
							👍
							<div class="tooltip-text">I'll have it done on time (Around @TimerService.CalculateEstimatedTimeOfTaskCompletion(ActivePomodoro, ActiveShortBreakTimer, ActiveLongBreakTimer, ActiveTask, Settings))</div>
						</div>
						<div class="task-info-row tooltip" @onclick="HandleNeedMoreTime" style="cursor: pointer;">
							⏰
							<div class="tooltip-text">I need more time (Add @((int)ActivePomodoro.Duration.TotalMinutes) min)</div>
						</div>
						<div class="task-info-row tooltip" @onclick="HandleTaskDone" style="cursor: pointer;">
							✅
							<div class="tooltip-text">I'm done with this task (Mark done & move to next)</div>
						</div>
					</div>
				</div>
			}
		}
	</div>

	<!-- Tasks Section -->
	<div class="tasks-section">
		@if (!IsOnBreak)
		{
			<div class="tasks-header">
				<div class="section-label">Tasks</div>
				<button class="menu-btn" @onclick="ToggleMenu">⋮</button>
			</div>
		}

		<!-- Popup menu -->
		@if (showMenu)
		{
			<div class="menu-popup" @onclick="() => showMenu = false">
				<button class="menu-item" @onclick="ClearFinished">Clear finished tasks</button>
				<button class="menu-item" @onclick="ConfirmClearAll">Clear all tasks</button>
				<button class="menu-item" @onclick="HideActiveTaskAsync">@(Settings.HideActiveTask ? "Show active task" : "Hide active task")</button>
				<button class="menu-item" @onclick="HideTasksAsync">@(Settings.HideTasks ? "Show tasks" : "Hide tasks")</button>
				<button class="menu-item" @onclick="OnResetPomodoros">Reset Pomodoro</button>
			</div>
		}

		@if (tasks == null)
		{
			<div class="loading">Loading tasks...</div>
		}
		else if (IsOnBreak)
		{
			<!-- Break display (no tasks, just break) -->
			<div class="section-label">@(GetBreakText() == "" ? "Take a break" : "Reminder")</div>

			<div class="break-screen">
				<div class="break-message">
					@if (GetBreakText() == "")
					{
						<div class="break-icon">🌴</div>
					}
					else
					{
						<p class="break-text">@GetBreakText()</p>
					}
				</div>
			</div>
		}
		else if (Settings.HideTasks)
		{
			<div class="tasks-hidden">Tasks are hidden.</div>
		}
		else
		{
			<!-- Tasks display -->
			@for (int i = 0; i < tasks.Count; i++)
			{
				var task = tasks[i];
				var index = i;

				<div class="task-wrapper"
					 @ondragover="(e) => OnDragOver(e, index)"
				@ondragover:preventDefault
					 @ondrop="(e) => OnDrop(e, index)"
				@ondrop:preventDefault
					 @ondragleave="OnDragLeave">

					<!-- Drop indicator line -->
					<div class="drop-indicator @(dropIndicatorIndex == index ? "visible" : "")"></div>

					<!-- Original task item -->
					<div class="task-item @(ActiveTaskId == task.TaskItemId ? "active" : "") @(task.IsDone ? "completed" : "") @(draggedTaskIndex == index ? "dragging" : "")"
						 draggable="@(editingTaskId == task.TaskItemId ? "false" : "true")"
						 @ondragstart="@(editingTaskId == task.TaskItemId ? null : (e) => OnDragStart(e, index))"
						 @ondragend="@(editingTaskId == task.TaskItemId ? null : OnDragEnd)"
						 @onclick="() => SetActiveTask(task.TaskItemId)"
						 @onwheel="(e) => AdjustEstimatedPomodoros(task.TaskItemId, e.DeltaY)"
						 @onwheel:preventDefault="true"
						 @ondblclick="() => StartEdit(task.TaskItemId)">

						<input type="checkbox"
							   class="task-checkbox"
							   checked="@task.IsDone"
							   @onclick="() => FinishTask(task.TaskItemId)"
							   @onclick:stopPropagation="true" />

						<div class="task-info">
							<span class="task-progress">@task.PomodorosRanOnTask/@task.EstimatedNumberOfPomodoros</span>
						</div>

						@if (editingTaskId == task.TaskItemId)
						{
							<input class="task-edit-input @(task.IsDone ? "completed" : "")"
								   @bind="task.Name"
								   @bind:event="oninput"
								   @onblur="() => FinishEdit(task)"
								   @onkeydown="(e) => HandleKeyDown(e, task)"
								   @onkeydown:stopPropagation="true"
								   @onclick:stopPropagation="true"
								   draggable="false"
							@ondragstart:preventDefault
								   @ref="editInputRef"
								   placeholder="What's your task?" />
						}
						else
						{
							<span class="task-name @(task.IsDone ? "completed" : "")">@task.Name</span>
						}

						<div class="task-actions">
							<button class="task-btn" @onclick="() => StartEdit(task.TaskItemId)" @onclick:stopPropagation="true">✎</button>
							<button class="task-btn" @onclick="() => DeleteTask(task.TaskItemId)" @onclick:stopPropagation="true">❌</button>
							<button class="task-btn" @onclick:stopPropagation="true">⋯</button>
						</div>
					</div>
				</div>

			}

			<!-- Final drop zone for bottom -->
			<div class="task-wrapper bottom-drop-zone @(IsDragging ? "active" : "")"
				 @ondragover="(e) => OnDragOver(e, tasks.Count)"
			@ondragover:preventDefault
				 @ondrop="(e) => OnDrop(e, tasks.Count)"
			@ondrop:preventDefault
				 @ondragleave="OnDragLeave">

				<div class="drop-indicator @(dropIndicatorIndex == tasks.Count ? "visible" : "")"></div>
			</div>

			<div class="add-task-section">
				<button class="add-task-btn" @onclick="AddTask">Add Task</button>
			</div>

		}
	</div>
</div>

@code {
	private bool IsDragging;
	private int? draggedTaskIndex;
	private int? dropIndicatorIndex;

	private void OnDragStart(DragEventArgs e, int index)
	{
		draggedTaskIndex = index;
		IsDragging = true;
		StateHasChanged();
	}

	private void OnDragEnd(DragEventArgs e)
	{
		draggedTaskIndex = null;
		dropIndicatorIndex = null;
		IsDragging = false;
		StateHasChanged();
	}

	private void OnDragLeave(DragEventArgs e)
	{
		dropIndicatorIndex = null;
		StateHasChanged();
	}

	private void OnDragOver(DragEventArgs e, int index)
	{
		e.DataTransfer.DropEffect = "move";

		if (draggedTaskIndex.HasValue && draggedTaskIndex != index)
		{
			dropIndicatorIndex = index;
			StateHasChanged();
		}
	}

	private async Task OnDrop(DragEventArgs e, int dropIndex)
	{
		if (draggedTaskIndex.HasValue && draggedTaskIndex != dropIndex)
		{
			await ReorderTasks(draggedTaskIndex.Value, dropIndex);
		}

		draggedTaskIndex = null;
		dropIndicatorIndex = null;
		StateHasChanged();
	}

	private async Task ReorderTasks(int fromIndex, int toIndex)
	{
		if (fromIndex < 0 || fromIndex >= tasks.Count || toIndex < 0 || toIndex > tasks.Count)
			return;

		var draggedTask = tasks[fromIndex];
		tasks.RemoveAt(fromIndex);

		if (toIndex > fromIndex)
			toIndex--;

		if (toIndex >= tasks.Count)
			tasks.Add(draggedTask);
		else
			tasks.Insert(toIndex, draggedTask);

		for (int i = 0; i < tasks.Count; i++)
		{
			tasks[i].SortOrder = i;
		}

		await TaskApiService.SaveTaskOrderAsync(tasks);

		StateHasChanged();
	}

	private ElementReference editInputRef;

	private async Task HandleKeyDown(KeyboardEventArgs e, TaskItemDto task)
	{
		if (e.Key == "Enter")
		{
			await FinishEdit(task);
		}
		else if (e.Key == "Tab")
		{
			int currentIndex = tasks.FindIndex(t => t.TaskItemId == task.TaskItemId);
			if (currentIndex >= 0 && currentIndex < tasks.Count - 1)
			{
				await EditPreviousOrNextTask(task, isPrevious: false);
			}
			else
			{
				await FinishEdit(task);
				await AddTask();
			}
		}
		else if (e.Key == "ArrowUp" || e.Key == "ArrowDown")
		{
			if (e.CtrlKey)
			{
				// Ctrl + ArrowUp / ArrowDown
				if (e.Key == "ArrowUp")
				{
					await MoveTaskUpOrDown(task, isUp: true);
				}
				else if (e.Key == "ArrowDown")
				{
					await MoveTaskUpOrDown(task, isUp: false);
				}
			}
			else if (e.ShiftKey)
			{
				await JS.InvokeVoidAsync("blazorPreventDefault", e.Code);

				// Shift + ArrowUp / ArrowDown
				if (e.Key == "ArrowUp")
				{
					await EditPreviousOrNextTask(task, isPrevious: true);
				}
				else if (e.Key == "ArrowDown")
				{
					await EditPreviousOrNextTask(task, isPrevious: false);
				}
			}
			// ArrowUp / ArrowDown
			else if (e.Key == "ArrowUp")
			{
				await AdjustEstimatedPomodoros(task.TaskItemId, -1);
			}
			else if (e.Key == "ArrowDown")
			{
				await AdjustEstimatedPomodoros(task.TaskItemId, 1);
			}
		}
	}

	private async Task EditPreviousOrNextTask(TaskItemDto task, bool isPrevious)
	{
		if (tasks == null || tasks.Count == 0) return;

		int currentIndex = tasks.FindIndex(t => t.TaskItemId == task.TaskItemId);
		if (currentIndex == -1) return;

		int newIndex = isPrevious ? currentIndex - 1 : currentIndex + 1;

		if (newIndex < 0 || newIndex >= tasks.Count) return;

		var nextTask = tasks[newIndex];
		await FinishEdit(task);
		await StartEdit(nextTask.TaskItemId);
	}


	private async Task MoveTaskUpOrDown(TaskItemDto task, bool isUp)
	{
		if (tasks == null) return;

		int currentIndex = tasks.FindIndex(t => t.TaskItemId == task.TaskItemId);

		if (currentIndex == -1) return;

		if (isUp && currentIndex == 0) return; // Already top
		if (!isUp && currentIndex == tasks.Count - 1) return; // Already bottom

		int swapIndex = isUp ? currentIndex - 1 : currentIndex + 1;

		var temp = tasks[swapIndex];
		tasks[swapIndex] = task;
		tasks[currentIndex] = temp;

		for (int i = 0; i < tasks.Count; i++)
		{
			tasks[i].SortOrder = i;
		}

		await TaskApiService.SaveTaskOrderAsync(tasks);

		await editInputRef.FocusAsync();

		StateHasChanged();
	}

	[Parameter] public CountdownTimerDto CurrentTimer { get; set; } = default!;
	[Parameter] public PomodoroTimerDto ActivePomodoro { get; set; } = default!;
	[Parameter] public ShortBreakTimerDto ActiveShortBreakTimer { get; set; } = default!;
	[Parameter] public LongBreakTimerDto ActiveLongBreakTimer { get; set; } = default!;
	[Parameter] public UserSettingsDto Settings { get; set; } = default!;

	[Parameter] public EventCallback OnResetPomodoros { get; set; }
	[Parameter] public EventCallback<UserSettingsDto> OnSave { get; set; }

	private List<TaskItemDto>? tasks = new();
	private TaskItemDto? activeTask;
	private int? ActiveTaskId => tasks.FirstOrDefault(t => t.IsActiveTask)?.TaskItemId;
	private int? editingTaskId;

	private bool showMenu;
	private bool IsOnBreak => CurrentTimer is ShortBreakTimerDto or LongBreakTimerDto;
	private string GetBreakText() => CurrentTimer is ShortBreakTimerDto ? Settings.ShortBreakText : Settings.LongBreakText;

	public bool AreAllTasksDone = false;
	public bool ShouldPlaySoundAfterAllTasksDone = false;
	private Timer? _debounceTimer;

	public TaskItemDto? ActiveTask
	{
		get => activeTask;
		set
		{
			activeTask = value;
			StateHasChanged();
		}
	}

	protected override async Task OnInitializedAsync()
	{
		tasks = await TaskApiService.GetAllAsync();

		// make it sort finished tasks at top? --- call it again if a task is unchecked?
		SortListByTaskOrder();

		// Clean up any tasks that are marked active but are done
		foreach (var t in tasks.Where(t => t.IsActiveTask && t.IsDone))
		{
			t.IsActiveTask = false;
			await TaskApiService.UpdateAsync(t);
		}

		await SetNextAvailableTaskIfNoneActive();

		ShouldPlaySoundAfterAllTasksDone = HasMoreTasks();
	}

	private void ToggleMenu() => showMenu = !showMenu;

	private async Task HideTasksAsync()
	{
		Settings.HideTasks = !Settings.HideTasks;

		await SaveAsync();
	}

	private async Task HideActiveTaskAsync()
	{
		Settings.HideActiveTask = !Settings.HideActiveTask;

		await SaveAsync();
	}

	private async Task SaveAsync()
	{
		await OnSave.InvokeAsync(Settings);
	}

	public bool HasMoreTasks() => tasks?.Any(t => !t.IsDone) == true;

	public void SortListByTaskOrder()
	{
		if (tasks == null) return;

		tasks = tasks.OrderBy(t => t.SortOrder).ToList();

		StateHasChanged();
	}

	public async Task IncrementActivePomodoroCount()
	{
		if (ActiveTask == null) return;

		ActiveTask.PomodorosRanOnTask++;
		await TaskApiService.UpdateAsync(ActiveTask);

		bool isTaskDone = ActiveTask.PomodorosRanOnTask >= ActiveTask.EstimatedNumberOfPomodoros;

		if (isTaskDone)
		{
			if (Settings.AutomaticallyMarkDoneTasks)
			{
				ActiveTask.IsDone = true;
				await TaskApiService.UpdateAsync(ActiveTask);
			}

			if (Settings.AutomaticallyClearDoneTasks)
				await DeleteTask(ActiveTask.TaskItemId);

			if (Settings.AutomaticallyProceedToNextTaskAfterDone)
				await SetNextTaskAsActive();
		}

		StateHasChanged();
	}

	public async Task SetNextAvailableTaskIfNoneActive()
	{
		if (ActiveTask == null && HasMoreTasks())
		{
			var nextTask = tasks.FirstOrDefault(t => !t.IsDone);
			if (nextTask != null)
			{
				nextTask.IsActiveTask = true;
				await TaskApiService.UpdateAsync(nextTask);
				ActiveTask = nextTask;
				StateHasChanged();
			}
		}
	}

	public async Task SetNextTaskAsActive()
	{
		if (ActiveTask != null)
		{
			ActiveTask.IsActiveTask = false;
			await TaskApiService.UpdateAsync(ActiveTask);
		}

		if (HasMoreTasks())
		{
			var nextTask = await GetNextTask();
			if (nextTask != null)
			{
				nextTask.IsActiveTask = true;
				await TaskApiService.UpdateAsync(nextTask);
				ActiveTask = nextTask;
			}
			else
			{
				ActiveTask = null;
			}
		}
		else
		{
			ActiveTask = null;
		}
	}

	public async Task<TaskItemDto?> GetNextTask()
	{
		var nextTask = tasks?.FirstOrDefault(t => !t.IsDone && !t.IsActiveTask);

		// var currentIndex = tasks!.FindIndex(t => t.TaskItemId == ActiveTask?.TaskItemId);
		// var nextTask = tasks!.Skip(currentIndex + 1).FirstOrDefault(t => !t.IsDone);

		if (nextTask != null)
		{
			await SetActiveTask(nextTask.TaskItemId);
			return nextTask;
		}
		return null;
	}


	private async Task ConfirmClearAll()
	{
		bool confirmed = await JS.InvokeAsync<bool>
			("confirm", "Are you sure you want to clear all tasks? This cannot be undone.");

		if (confirmed)
		{
			ClearAll();
		}
	}

	private void ClearFinished()
	{
		foreach (var task in tasks!.Where(t => t.IsDone).ToList())
		{
			_ = TaskApiService.DeleteAsync(task.TaskItemId);
			tasks.Remove(task);
		}
	}

	private void ClearAll()
	{
		foreach (var task in tasks!.ToList())
		{
			_ = TaskApiService.DeleteAsync(task.TaskItemId);
		}
		tasks!.Clear();
		activeTask = null;
	}

	public async Task AddTask()
	{
		var newTask = new TaskItemDto
			{
				Name = "My task",
				Description = "",
				ProjectId = 0 // optional, will be replaced with default project
			};

		var created = await TaskApiService.CreateAsync(newTask);

		if (created != null)
		{
			tasks!.Add(created);
			editingTaskId = created.TaskItemId;
			ShouldPlaySoundAfterAllTasksDone = true;
			StateHasChanged();

			await Task.Delay(10);
			await JS.InvokeVoidAsync("selectElementText", editInputRef);
		}
	}

	private async Task SetActiveTask(int taskId)
	{
		var clickedTask = tasks.FirstOrDefault(t => t.TaskItemId == taskId);
		if (clickedTask == null || clickedTask.IsDone)
			return;

		foreach (var t in tasks)
			t.IsActiveTask = false;

		ActiveTask = clickedTask;
		clickedTask.IsActiveTask = true;
		await TaskApiService.UpdateAsync(clickedTask);
		StateHasChanged();
	}

	private async Task FinishTask(int taskId)
	{
		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskId);
		if (task == null) return;

		await CompleteTaskAsync(task, !task.IsDone);
	}

	private async Task StartEdit(int taskId)
	{
		editingTaskId = taskId;
		StateHasChanged();

		await Task.Delay(10);
		await JS.InvokeVoidAsync("selectElementText", editInputRef);
	}

	private async Task FinishEdit(TaskItemDto task)
	{
		editingTaskId = null;

		if (string.IsNullOrWhiteSpace(task.Name))
		{
			await DeleteTask(task.TaskItemId);
			return;
		}

		if (task.Name.Length > 100)
		{
			task.Name = "Task name too long! (Max 100 chars)";
			StartEdit(task.TaskItemId);
		}

		await TaskApiService.UpdateAsync(task);
	}

	private async Task DeleteTask(int taskItemId)
	{
		var success = await TaskApiService.DeleteAsync(taskItemId);
		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskItemId);

		if (success)
			tasks!.RemoveAll(t => t.TaskItemId == taskItemId);

		if (task != null && task.IsActiveTask)
			activeTask = null;
	}

	private async Task HandleOnTime()
	{
		// positive effect to mark task as on time ? toggle other buttons when one is selected?
		await JS.InvokeVoidAsync("playClickSound");
	}

	private async Task HandleNeedMoreTime()
	{
		if (ActiveTask != null)
		{
			ActiveTask.EstimatedNumberOfPomodoros++;
			await TaskApiService.UpdateAsync(ActiveTask);
			StateHasChanged();
		}
		await JS.InvokeVoidAsync("playClickSound");
	}

	private async Task HandleTaskDone()
	{
		if (ActiveTask != null)
			await CompleteTaskAsync(ActiveTask, true);

		await JS.InvokeVoidAsync("playClickSound");

		if (!HasMoreTasks())
		{
			await JS.InvokeVoidAsync("playTasksDoneSound");
			ShouldPlaySoundAfterAllTasksDone = false;
		}
	}

	private async Task AdjustEstimatedPomodoros(int taskId, double deltaY)
	{
		var task = tasks!.FirstOrDefault(t => t.TaskItemId == taskId);
		if (task == null) return;

		int change = deltaY < 0 ? 1 : -1;
		int newValue = Math.Max(1, task.EstimatedNumberOfPomodoros + change);

		if (newValue == task.EstimatedNumberOfPomodoros) return;

		task.EstimatedNumberOfPomodoros = newValue;
		StateHasChanged();

		_debounceTimer?.Dispose();

		bool isDone = newValue <= task.PomodorosRanOnTask;
		task.IsDone = isDone;

		_debounceTimer = new Timer(async _ =>
		{
			if (isDone)
			{
				await CompleteTaskAsync(task, isDone);
			}
			else
			{
				await TaskApiService.UpdateAsync(task);
			}
		}, null, 500, Timeout.Infinite);
	}


	private async Task CompleteTaskAsync(TaskItemDto task, bool isDone)
	{
		if (task == null) return;

		task.IsDone = isDone;
		await TaskApiService.UpdateAsync(task);

		if (task.TaskItemId == ActiveTask?.TaskItemId)
		{
			ActiveTask.IsActiveTask = false;
			ActiveTask = null;

			if (isDone && HasMoreTasks())
			{
				await SetNextTaskAsActive();
			}
		}

		ShouldPlaySoundAfterAllTasksDone = HasMoreTasks() == false ? false : true;

		StateHasChanged();
	}

}
